  session_created_at  timestamptz,
  session_expires_at  timestamptz,
  session_last_seen   timestamptz,
  session_revoked_at  timestamptz,
  user_agent          text,
  remote_addr         text,
  session_metadata    jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = sacir, public
AS $$
DECLARE
  v_claims     jsonb := NULLIF(current_setting('request.jwt.claims', true), '')::jsonb;
  v_email      text;
  v_role       text;
  v_session_id uuid;
  v_session    sacir.sessions;
BEGIN
  IF v_claims IS NULL THEN
    RETURN;
  END IF;

  v_email      := v_claims->>'email';
  v_role       := v_claims->>'role';
  v_session_id := (v_claims->>'sid')::uuid;

  IF v_email IS NULL OR v_session_id IS NULL THEN
    RETURN;
  END IF;

  v_session := sacir.touch_session(v_session_id);

  IF v_session.id IS NULL THEN
    RETURN;
  END IF;

  email              := v_email;
  role               := v_role;
  session_id         := v_session.id;
  session_created_at := v_session.created_at;
  session_expires_at := v_session.expires_at;
  session_last_seen  := v_session.last_seen_at;
  session_revoked_at := v_session.revoked_at;
  user_agent         := v_session.user_agent;
  remote_addr        := v_session.remote_addr;
  session_metadata   := v_session.metadata;

  RETURN NEXT;
END;
$$;

REVOKE ALL ON FUNCTION sacir.current_user_info() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION sacir.current_user_info() TO anon;

CREATE OR REPLACE VIEW sacir.current_user AS
SELECT * FROM sacir.current_user_info();

-- RPC de login (assinatura usada pelo PostgREST OpenAPI: p_email, p_pin)
CREATE OR REPLACE FUNCTION sacir.login(p_email text, p_pin text, OUT token text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = sacir, public
AS $$
DECLARE
  v_role        text;
  v_secret      text := coalesce(
                      nullif(current_setting('pgrst.jwt_secret', true), ''),
                      nullif(current_setting('app.jwt_secret', true), '')
                    );
  v_ttl_seconds integer := NULLIF(current_setting('app.jwt_ttl_seconds', true), '')::integer;
  v_session_id  uuid := gen_random_uuid();
  v_expires_at  timestamptz;
  v_user_agent  text := NULLIF(current_setting('request.header.user-agent', true), '');
  v_forwarded   text := NULLIF(current_setting('request.header.x-forwarded-for', true), '');
  v_real_ip     text := NULLIF(current_setting('request.header.x-real-ip', true), '');
  v_remote      text := NULLIF(current_setting('request.remote_addr', true), '');
  v_client_addr text;
  v_token       text;
BEGIN
  IF v_secret IS NULL THEN
    RAISE EXCEPTION 'jwt secret not configured';
  END IF;

  IF v_ttl_seconds IS NULL OR v_ttl_seconds <= 0 THEN
    v_ttl_seconds := 3600;
  END IF;

  IF p_pin IS NULL OR p_pin !~ '^\d{6}$' THEN
    RAISE invalid_password USING MESSAGE = 'invalid user or password';
  END IF;

  SELECT u.role
    INTO v_role
    FROM sacir.auth_users u
   WHERE u.email = p_email
     AND u.pin   = encode(digest(p_pin, 'sha256'), 'hex');

  IF v_role IS NULL THEN
    UPDATE sacir.auth_users
       SET tentativas_invalidas = tentativas_invalidas + 1,
           last_failed_login    = CURRENT_TIMESTAMP
     WHERE email = p_email;
    RAISE invalid_password USING MESSAGE = 'invalid user or password';
  END IF;

  UPDATE sacir.auth_users
     SET tentativas_invalidas = 0,
         last_failed_login    = NULL,
         updated_at           = CURRENT_TIMESTAMP
   WHERE email = p_email;

  v_client_addr := COALESCE(
                      NULLIF(split_part(v_forwarded, ',', 1), ''),
                      v_real_ip,
                      v_remote
                    );

  v_expires_at := CURRENT_TIMESTAMP + make_interval(secs => v_ttl_seconds);

  v_token := public.jwt_sign(
               json_build_object(
                 'role',  v_role,
                 'email', p_email,
                 'exp',   EXTRACT(EPOCH FROM v_expires_at)::bigint,
                 'sid',   v_session_id
               ),
               v_secret
             );

  INSERT INTO sacir.sessions (id, user_email, expires_at, user_agent, remote_addr, token)
  VALUES (v_session_id, p_email, v_expires_at, v_user_agent, v_client_addr, v_token);

  token := v_token;
  RETURN;
END;
$$;

-- Permissões finas
REVOKE ALL ON FUNCTION sacir.login(text, text) FROM PUBLIC;
GRANT  EXECUTE ON FUNCTION sacir.login(text, text) TO anon;

-- RPC de logout (revoga sessão atual)
CREATE OR REPLACE FUNCTION sacir.logout()
RETURNS TABLE (revoked boolean)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = sacir, public
AS $$
DECLARE
  v_claims     jsonb := NULLIF(current_setting('request.jwt.claims', true), '')::jsonb;
  v_session_id uuid;
  v_token      text := sacir.current_token();
BEGIN
  IF v_claims IS NULL THEN
    revoked := FALSE;
    RETURN NEXT;
    RETURN;
  END IF;

  IF v_token IS NULL THEN
    revoked := FALSE;
    RETURN NEXT;
    RETURN;
  END IF;

  v_session_id := (v_claims->>'sid')::uuid;

  IF v_session_id IS NULL THEN
    revoked := FALSE;
    RETURN NEXT;
    RETURN;
  END IF;

  UPDATE sacir.sessions
     SET revoked_at = CURRENT_TIMESTAMP,
         last_seen_at = CURRENT_TIMESTAMP
   WHERE id = v_session_id
     AND token = v_token
     AND revoked_at IS NULL
  RETURNING TRUE INTO revoked;

  IF NOT FOUND THEN
    revoked := FALSE;
  END IF;

  RETURN NEXT;
END;
$$;

REVOKE ALL ON FUNCTION sacir.logout() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION sacir.logout() TO anon;

GRANT  USAGE ON SCHEMA sacir TO anon;

-- Leitura por padrão em todas as tabelas do schema sacir
GRANT SELECT ON ALL TABLES IN SCHEMA sacir TO anon;
ALTER DEFAULT PRIVILEGES IN SCHEMA sacir GRANT SELECT ON TABLES TO anon;

-- Revoga acesso direto às tabelas sensíveis de sessão/auditoria
REVOKE ALL ON TABLE sacir.sessions  FROM PUBLIC;
REVOKE ALL ON TABLE sacir.audit_log FROM PUBLIC;
GRANT SELECT ON TABLE sacir.sessions  TO authenticator;
GRANT SELECT ON TABLE sacir.audit_log TO authenticator;
REVOKE SELECT ON TABLE sacir.sessions  FROM anon;
REVOKE SELECT ON TABLE sacir.audit_log FROM anon;
